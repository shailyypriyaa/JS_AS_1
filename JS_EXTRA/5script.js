/* HTTP Requests and Response:
üåê What is an HTTP Request?
An HTTP request is a message sent from the client (browser or JS app) to the server asking for data or to perform an action.
Common HTTP Methods:
GET: Retrieve data (e.g., read a blog post)
POST: Send data (e.g., submit a form)
PUT: Update existing data
DELETE: Remove data
üì• What is an HTTP Response?
An HTTP response is the server‚Äôs reply to the request, which includes:
Status code (e.g., 200 OK, 404 Not Found)
Headers (meta info)
Body (actual content/data)
‚úÖ Making HTTP Requests in JavaScript
There are 3 main ways:
1. fetch() API (Modern, Promise-based)
fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => response.json()) // parse response as JSON
  .then(data => console.log(data))   // use the data
  .catch(error => console.error('Error:', error));
üîπ What it does:
Sends a GET request by default
Returns a Promise
You can customize it with method, headers, body, etc.
2. fetch() with POST and JSON
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    title: 'Hello',
    body: 'World',
    userId: 1
  })
})
.then(response => response.json())
.then(data => console.log(data));
3. Using async/await with fetch()
async function getPost() {
  try {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error("Fetch error:", err);
  }
}
getPost();
4. Using Axios (third-party library)
Install via npm or CDN.
npm install axios
import axios from 'axios';
axios.get('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => console.log(response.data));
üì¶ HTTP Response Structure
When you use fetch(), the response object looks like:
fetch(url).then(response => {
  console.log(response.status);   // e.g., 200
  console.log(response.ok);       // true if status is 200‚Äì299
  console.log(response.headers);  // Headers object
});
üî¢ Common Status Codes
Code	Meaning
200	OK (success)
201	Created (on POST)
400	Bad Request
401	Unauthorized
404	Not Found
500	Internal Server Error
üîê Setting Headers
Headers define meta info about requests and responses.
fetch(url, {
  headers: {
    'Authorization': 'Bearer token',
    'Content-Type': 'application/json'
  }
});
*/

/* API in JS:
API stands for Application Programming Interface.
In JavaScript (especially web development), API usually refers to a web service that allows your app to send and receive data from a server.
Think of it as a bridge between your frontend (JavaScript) and backend (database/server).
üß≠ Types of APIs in JavaScript
Web APIs ‚Äì Provided by the browser (DOM, Fetch API, LocalStorage, etc.)
Third-Party APIs ‚Äì External services like GitHub API, OpenWeather, etc.
REST APIs ‚Äì A common pattern to structure web APIs using HTTP methods
JavaScript APIs (Browser) ‚Äì Interfaces to work with hardware, clipboard, etc.
üí¨ Example: REST API
A REST API gives endpoints like:
Method	URL	Purpose
GET	/users	Get all users
GET	/users/1	Get user with id=1
POST	/users	Create a user
PUT	/users/1	Update user id=1
DELETE	/users/1	Delete user id=1
üöÄ How to Call an API in JavaScript?
‚úÖ Using fetch() ‚Äì Built-in Web API
fetch('https://jsonplaceholder.typicode.com/users')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));
‚úÖ Using async/await (Modern)
async function getUsers() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    const users = await response.json();
    console.log(users);
  } catch (err) {
    console.error('API failed:', err);
  }
}
getUsers();
‚úÖ Using POST Method to Send Data
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    title: 'Hello',
    body: 'World',
    userId: 1
  })
})
.then(res => res.json())
.then(data => console.log(data));
üõ† Common API Terms
Term	Meaning
Endpoint	Specific URL to access a resource (/users/1)
Payload	Data sent in a request (usually in POST/PUT)
Header	Meta info (like auth token, content type)
Response	Server‚Äôs reply (data, message, status)
Status Code	HTTP code (200, 404, 500) indicating result
JSON	JavaScript Object Notation ‚Äì common data format

üß† Real-Life Use Cases
Weather apps use Weather APIs
Login forms use Auth APIs
E-commerce sites use Payment APIs
Social platforms use Post/User APIs

üß™ Bonus: Browser APIs
JavaScript can also access built-in APIs like:
LocalStorage / SessionStorage
Geolocation API
Clipboard API
Notification API

navigator.geolocation.getCurrentPosition(pos => {
  console.log(pos.coords.latitude, pos.coords.longitude);
});








Browser API:
üîπ 1. LocalStorage API
‚úÖ What it is:
Stores key-value data in the browser permanently (until cleared).
Data persists even after the browser is closed or refreshed.
‚úÖ Example:
// Save data
localStorage.setItem("name", "Shaily");
// Get data
const name = localStorage.getItem("name"); // "Shaily"
// Remove data
localStorage.removeItem("name");
// Clear all
localStorage.clear();
‚ö†Ô∏è Note:
Stores only strings. Use JSON.stringify() and JSON.parse() for objects.
üîπ 2. SessionStorage API
‚úÖ What it is:
Works just like LocalStorage but data is only kept for the current tab/session.
Once the tab or window is closed, the data is gone.
‚úÖ Example:
sessionStorage.setItem("token", "abc123");
console.log(sessionStorage.getItem("token")); // "abc123"
üîπ 3. Geolocation API
‚úÖ What it is:
Allows access to the user's current physical location.
Asks the user for permission before sharing.
‚úÖ Example:
navigator.geolocation.getCurrentPosition((position) => {
  console.log(position.coords.latitude);
  console.log(position.coords.longitude);
});
‚ö†Ô∏è Notes:
Works only in secure (HTTPS) contexts.
Needs user permission via browser popup.
üîπ 4. Clipboard API
‚úÖ What it is:
Lets you read from or write to the system clipboard.
Useful for "Copy to Clipboard" buttons.
‚úÖ Example: Copy Text
navigator.clipboard.writeText("Copied text!").then(() => {
  alert("Text copied to clipboard");
});
‚úÖ Example: Paste Text
navigator.clipboard.readText().then(text => {
  console.log("Pasted:", text);
});
‚ö†Ô∏è Notes:
Requires HTTPS and sometimes user interaction (e.g., button click).
üîπ 5. Notification API
‚úÖ What it is:
Used to show desktop/browser notifications from the website.
‚úÖ Example:
if (Notification.permission === "granted") {
  new Notification("Hello from JS!");
} else {
  Notification.requestPermission().then(permission => {
    if (permission === "granted") {
      new Notification("Thanks for allowing notifications!");
    }
  });
}
‚úÖ Summary of Browser APIs
API	Purpose
LocalStorage	Store data permanently in browser
SessionStorage	Store data for one session/tab
Geolocation	Access user's current physical location
Clipboard	Read/write to system clipboard
Notification	Show desktop/browser notifications
*/

/* fetch API in JS:
üåê What is the Fetch API?
The Fetch API is a built-in browser API that allows you to make network requests similar to XMLHttpRequest, but with a simpler and more modern Promise-based syntax.
‚úÖ It‚Äôs used to get, post, update, or delete data from web servers or APIs.
‚úÖ Basic Syntax:
fetch(url, options)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));
üî∏ 1. GET Request (Fetch Data)
fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(res => res.json()) // Convert response to JSON
  .then(data => console.log(data))
  .catch(err => console.log('Fetch failed:', err));
‚úîÔ∏è This makes a GET request by default.
üî∏ 2. POST Request (Send Data)
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    title: 'My Post',
    body: 'Hello World',
    userId: 1
  })
})
.then(res => res.json())
.then(data => console.log(data))
.catch(err => console.log('Error:', err));
‚úîÔ∏è Use POST, headers, and body to send data.
‚úÖ What This Code Does
It sends a POST request to:
https://jsonplaceholder.typicode.com/posts
With a JSON body containing:
{
  "title": "My Post",
  "body": "Hello World",
  "userId": 1
}
‚úÖ Step-by-Step Breakdown
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',                      // 1Ô∏è‚É£ HTTP method: POST (used to send data)
  headers: {
    'Content-Type': 'application/json' // 2Ô∏è‚É£ Tells server we're sending JSON data
  },
  body: JSON.stringify({               // 3Ô∏è‚É£ Convert JS object to JSON string
    title: 'My Post',
    body: 'Hello World',
    userId: 1
  })
})
method: 'POST' ‚Üí We're sending (posting) data to the server.
headers ‚Üí We tell the server we're sending JSON using:
'Content-Type': 'application/json'
body ‚Üí We send the actual data.
It must be a string, so we use JSON.stringify(...).
‚úÖ Handling the Response:
.then(res => res.json())               // 4Ô∏è‚É£ Convert response to JS object
.then(data => console.log(data))      // 5Ô∏è‚É£ Use the result
.catch(err => console.log('Error:', err)); // 6Ô∏è‚É£ Handle any network or fetch errors
res.json() parses the response into a usable JavaScript object.
You can now work with the returned data in .then(...).
‚úÖ Sample Output (Simulated)
Since jsonplaceholder.typicode.com is a fake test API, it will echo the data back with a fake id:
{
  title: 'My Post',
  body: 'Hello World',
  userId: 1,
  id: 101 // fake ID generated
}








What should we use to handle the response, and why?
‚úÖ Why Use .then(res => res.json()) After Sending Data?
Even though you are sending data, the server usually responds back with:
A success message
The newly created data
A status (201 Created, etc.)
Or an error response
To read that response, you need to parse it. This is where:
.then(res => res.json())
comes in.
‚úÖ What Does res.json() Do?
It reads the response body stream.
It parses the JSON string into a JavaScript object.
Allows you to use the response in your code:
.then(data => console.log(data))
‚úÖ So, even though you‚Äôre sending, you still need res.json() to read the server‚Äôs reply in JSON format.
üîÅ Analogy:
üîº You send a form (POST with body)
üîΩ Server replies with a receipt (response in JSON)
üì¶ You unwrap the receipt using res.json() to actually see what's inside
üî∏ 3. Using async/await (Modern way)
async function getPost() {
  try {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error("Fetch error:", err);
  }
}
getPost();
üî∏ 4. Common Options in fetch()
fetch(url, {
  method: 'POST' | 'GET' | 'PUT' | 'DELETE',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token' // Optional auth
  },
  body: JSON.stringify(data), // Only for POST/PUT
})
üî∏ 5. Response Properties
After a fetch, the response object contains useful data:
fetch(url).then(response => {
  console.log(response.status);    // 200, 404, etc.
  console.log(response.ok);        // true if 200‚Äì299
  console.log(response.headers);   // Response headers
});
üß† Common Status Codes
Code	Meaning
200	OK
201	Created
400	Bad Request
401	Unauthorized
404	Not Found
500	Server Error
‚ö†Ô∏è Things to Remember
fetch() doesn't throw errors for HTTP errors (e.g., 404). You must check response.ok yourself.
You often need to parse the response with res.json(), res.text(), etc.
It's asynchronous and returns a Promise.
*/

/* XMLHTTPRequest:
XMLHttpRequest (XHR) is a built-in JavaScript object that allows web pages to communicate with servers without reloading the page. It was introduced long before fetch() and is the foundation of AJAX (Asynchronous JavaScript and XML).
üîπ Purpose of XHR
Send and receive data from a web server.
Communicate asynchronously (without refreshing the page).
Useful for making HTTP requests like:
GET (fetching data)
POST (sending data)
PUT (updating data)
DELETE (removing data)
üîπ Key Features
Supports asynchronous and synchronous requests (though sync is discouraged).
Works in all modern browsers.
Allows interaction with APIs, JSON, XML, or plain text.
Can be used with event listeners or via polling.
üîπ How It Works (Conceptually)
Create an XHR object: new XMLHttpRequest().
Initialize a request using .open(method, url, async).
Send the request using .send(data).
Handle the response using the .onreadystatechange event or other event handlers like .onload.
üîπ Why Use XHR (Historically)
Before ES6 and fetch(), XHR was the primary tool to perform AJAX operations in JavaScript. It enabled dynamic websites and modern app-like behavior long before fetch or third-party libraries like Axios.
üîπ Downsides of XHR
More verbose and complex than fetch().
Requires manual handling of ready states and status codes.
Lacks the Promise-based interface, making chaining and error handling harder.
Cannot be used easily with async/await.
*/

/* HTTP Payload Body:
The HTTP payload body (often just called the "body") is the actual data sent with an HTTP request or response.
In a request, it contains the data you're sending to the server (e.g., form data, JSON, file).
In a response, it contains the data the server sends back (e.g., HTML, JSON, image).
üì§ Request Payload Body (Client ‚Üí Server)
When sending data using methods like POST, PUT, or PATCH, the payload body holds the content.
üî∏ Common formats of request body:
JSON ‚Üí { "name": "Shaily" }
Form Data ‚Üí name=Shaily&age=25
Multipart ‚Üí For file uploads
üí° In JavaScript (using fetch):
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'  // tells server it's JSON
  },
  body: JSON.stringify({
    name: 'Shaily',
    age: 25
  })  // ‚Üê This is the HTTP payload body
});
üì• Response Payload Body (Server ‚Üí Client)
When the server sends back a response, the response body may contain:
JSON (API response)
HTML (page content)
Text, images, etc.
In JavaScript, you handle it like this:
fetch('https://api.example.com/user')
  .then(res => res.json()) // Parses the response body (payload)
  .then(data => console.log(data));
üö´ When Payload Body is Not Used
In GET requests, the body is typically ignored by the server.
Only POST, PUT, PATCH, DELETE usually carry a payload body.
*/

/* Unit Testing with Jest:
Unit testing is the practice of testing individual functions or components of your code in isolation, to ensure they behave as expected.
üîß What is Jest?
Jest is a JavaScript testing framework created by Facebook. It's widely used for testing:
JavaScript logic
React components
Node.js backends

‚úÖ Why use Jest?
Easy setup
Built-in test runner
Built-in assertion library (no need for extra tools)
Supports mocking, async testing, snapshots, coverage reports

üöÄ Installing Jest
If you're using Node.js:
npm install --save-dev jest
Add this to package.json:
"scripts": {
  "test": "jest"
}
‚úèÔ∏è Sample Code ‚Äì math.js
function add(a, b) {
  return a + b;
}
function subtract(a, b) {
  return a - b;
}
module.exports = { add, subtract };
‚úÖ Writing Unit Tests ‚Äì math.test.js
const { add, subtract } = require('./math');
test('adds two numbers', () => {
  expect(add(2, 3)).toBe(5);
});
test('subtracts two numbers', () => {
  expect(subtract(5, 2)).toBe(3);
});
üìå Running the Tests
npm test
Jest will automatically find all files ending in .test.js or .spec.js and run the tests.
‚è± Testing Async Code (Promises)
test('resolves to data', async () => {
  const data = await fetchData(); // Assume this returns a Promise
  expect(data).toBe('result');
});
üß™ Mocking Functions
Jest can mock functions, modules, or timers for isolated testing.
const mockFn = jest.fn();
mockFn('hello');
expect(mockFn).toHaveBeenCalledWith('hello');

‚úÖ What is Mocking in Jest?
Mocking means replacing real functions with fake (mock) functions during tests so you can:
Track how they were called
Control what they return
Test in isolation (without real side effects)
‚úÖ Example Code:
const mockFn = jest.fn();        // 1. Create a mock function
mockFn('hello');                 // 2. Call it with 'hello'
expect(mockFn).toHaveBeenCalledWith('hello'); // 3. Assert it was called correctly
‚úÖ Step-by-Step Explanation
üîπ 1. const mockFn = jest.fn();
Creates a mock function using jest.fn()
It‚Äôs a stand-in that doesn‚Äôt do anything by default, but records how it was used
You can call it just like a normal function
üîπ 2. mockFn('hello');
Call the mock function with 'hello'
Jest tracks:
That it was called
What arguments were passed
üîπ 3. expect(mockFn).toHaveBeenCalledWith('hello');
This is the test assertion
It checks that:
mockFn was called at least once
With 'hello' as its argument
‚úÖ If it was, the test passes.
‚ùå If not, the test fails.

Jest Functions Overview
üìÅ File 1: math.js
This is a basic JavaScript file with two functions:
function add(a, b) {
  return a + b;
}
function getUser() {
  return { name: "Shaily", age: 25 };
}
module.exports = { add, getUser };
üìÅ File 2: math.test.js
This is your test file using Jest:
const { add, getUser } = require('./math');
// üî∏ test() defines a test case
test('adds 2 + 3 to equal 5', () => {
  // üî∏ expect() sets up the value you're testing
  // üî∏ toBe() checks exact value (like ===)
  expect(add(2, 3)).toBe(5);
});
// üî∏ toEqual() checks deep equality (for objects)
test('returns user object', () => {
  expect(getUser()).toEqual({ name: "Shaily", age: 25 });
});
// üî∏ .not.toBe() checks inequality
test('2 + 2 is not 5', () => {
  expect(add(2, 2)).not.toBe(5);
});
‚úÖ To run the test
If Jest is installed, run:
npm test
Or:
npx jest
üß† What Each Jest Function Does:
Function	    What it does
test()	        Defines a test case
expect(value)	Sets up the actual value to test
.toBe(expected)	Checks if value === expected
.toEqual(expected)	Checks deep equality (use for comparing arrays/objects)
.not.toBe()	    Asserts that the value is not equal to the expected value
*/

/* Debugging in JS:
üîπ 1. console.log() Statements
The simplest and most widely used tool.
let name = "Shaily";
console.log("Name is:", name);
Use it to:
Print variable values
Track function calls
See flow of execution
Also available:
console.error()
console.warn()
console.table()
üîπ 2. Browser Developer Tools (DevTools)
Every modern browser (Chrome, Firefox, Edge) has DevTools built in.
How to open:
Right-click ‚Üí Inspect ‚Üí Console / Sources tab
Or press F12 or Ctrl+Shift+I
Features:
See errors in the Console tab
Step through your code line-by-line in the Sources tab
Set breakpoints to pause execution
Watch variables in real-time
Inspect the Call Stack to see the path your function took
üîπ 3. Breakpoints
A breakpoint tells the browser to pause code execution at a specific line.
How:
Go to the Sources tab
Click on the line number to set a breakpoint
Refresh or re-run the code
Execution will pause at that line so you can inspect variables
üîπ 4. debugger Statement
You can write a debugger; statement in your JS code to automatically trigger DevTools.
function test() {
  let x = 10;
  debugger; // pauses here
  let y = x + 5;
  return y;
}
test();
When DevTools is open, the browser will pause on the debugger; line.
üîπ 5. Stack Traces and Error Messages
When an error occurs, JS shows:
The error type (e.g., TypeError, ReferenceError)
A message (e.g., x is not defined)
The file name and line number
A stack trace (the list of function calls that led to the error)
Use this to trace where the bug happened.
üîπ 6. Linting Tools
Linters like ESLint help catch issues before you run the code.
Example:
const x = 5
console.log(x)
A linter will highlight the missing semicolons or unused variables.
üîπ 7. Try-Catch Blocks
Used to catch and handle errors gracefully, especially for risky code like API calls.
try {
  let result = riskyFunction();
} catch (error) {
  console.error("Something went wrong:", error);
}
*/

/* Performance Optimization and Security in JS:
üöÄ JavaScript Performance Optimization
Performance optimization in JavaScript helps make your app faster, more responsive, and efficient. Here's how you can improve performance:
üîπ 1. Avoid Unnecessary DOM Manipulation
Accessing and modifying the DOM is expensive.
Minimize direct DOM updates; use batch updates.
// Instead of this inside a loop:
element.innerHTML += `<li>${item}</li>`;
// Do this:
let html = '';
items.forEach(item => html += `<li>${item}</li>`);
element.innerHTML = html;
üîπ 2. Debounce or Throttle Events
Optimize high-frequency events like scroll, resize, keyup using debounce or throttle to limit function calls.
üîπ 3. Use requestAnimationFrame() for animations
It syncs updates with the browser's refresh rate.
üîπ 4. Avoid Memory Leaks
Clear intervals/timeouts if no longer needed.
Remove event listeners when elements are removed.
Watch for large objects that stay in memory.
üîπ 5. Efficient Loops and Data Structures
Use for instead of forEach if speed is critical.
Choose the right data structure (Set, Map for large collections).
üîπ 6. Use Web Workers for Heavy Computation
Offload CPU-heavy tasks to a Web Worker so the main thread doesn't freeze.
üîπ 7. Minify and Bundle Code
Use tools like Webpack or Vite to:
Minify JS (remove whitespace/comments)
Bundle multiple files for fewer network requests

üîí JavaScript Security Best Practices
JavaScript is exposed to the browser, so it‚Äôs vulnerable to attacks. Here‚Äôs how to secure it:
üîπ 1. Avoid eval()
Never use eval() ‚Äî it executes any string as JS, which opens your site to code injection.
‚úÖ eval() in JavaScript
eval() is a built-in JavaScript function that evaluates a string as JavaScript code and executes it immediately.
üîπ Syntax:
eval(string)
string: A string of valid JavaScript code
üß™ Example:
const x = 10;
const result = eval('x + 5');
console.log(result); // 15
Here, 'x + 5' is a string, but eval() executes it as if it's real code, and returns 15.
‚ö†Ô∏è Why eval() Is Dangerous (Avoid It!)
Using eval() is strongly discouraged because:
üî• Problem	‚ùå Why it‚Äôs bad
‚ùó Security risk	Can execute arbitrary malicious code from input
üê¢ Performance	JavaScript engines can‚Äôt optimize eval
üß† Hard to debug	Makes code hard to understand and maintain
üö´ Bad Practice Example:
const userInput = "alert('Hacked!')";
eval(userInput); // ‚ùå dangerous if input is untrusted
‚úÖ Safe Alternative Example:
Instead of this:
eval("x = 5");
Do this:
const x = 5;

üîπ 2. Escape User Input
Sanitize any user input you display in the DOM to prevent XSS (Cross-Site Scripting).
Example of a bad practice:
element.innerHTML = `<div>${userInput}</div>`; // Risky!
üîπ 3. Use HTTPS
Always serve JS files over HTTPS to prevent MITM (Man-in-the-Middle) attacks.
üîπ 4. Limit Sensitive Data in JS
Don‚Äôt store tokens, secrets, or passwords in frontend JavaScript ‚Äî it‚Äôs visible to anyone in DevTools.
üîπ 5. Content Security Policy (CSP)
Set up a CSP header to restrict what scripts can run on your page.
Example:
Content-Security-Policy: default-src 'self'; script-src 'self'
üîπ 6. Use strict mode
"use strict";
Enables cleaner syntax and blocks insecure actions like accidental globals.
üîπ 7. Validate Inputs on Server Side
Client-side validation is good for user experience, but it‚Äôs not secure alone. Always validate again on the server.
*/

/* Lazy Loading in JS:
Lazy loading is a technique where resources are loaded only when needed, rather than loading everything up front.
It improves:
‚ö° Performance (faster initial load)
üß† Efficiency (only loads what the user interacts with)
üî∏ Where Lazy Loading is Used in JavaScript?
Images / Media
Modules (code splitting)
Components (e.g., in React)
Data (API calls when scrolling)

‚úÖ 1. Lazy Loading Images (HTML + JS)
üîπ HTML (with loading="lazy"):
<img src="image.jpg" loading="lazy" alt="..." />
‚úÖ Loads the image only when it enters the viewport.

‚úÖ 2. Lazy Loading JS Modules (Code Splitting)
In modern JS (ES2020+ or via bundlers like Webpack), you can dynamically import modules only when needed.
üîπ Syntax:
button.addEventListener('click', async () => {
  const module = await import('./heavyModule.js');
  module.run();
});
‚úÖ This will only load heavyModule.js when the user clicks the button.
‚úÖ 3. Lazy Loading React Components
import React, { lazy, Suspense } from 'react';
const LazyComponent = lazy(() => import('./MyComponent'));
function App() {
  return (
    <Suspense fallback={<p>Loading...</p>}>
      <LazyComponent />
    </Suspense>
  );
}
‚úÖ Only loads MyComponent when it‚Äôs rendered.
‚úÖ 4. Lazy Loading Data (e.g., Infinite Scroll)
window.addEventListener('scroll', () => {
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
    loadMoreData(); // fetch more data from server
  }
});
‚úÖ Loads more data only when user reaches bottom of the page.
*/